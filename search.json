[{"title":"Js模拟惯性滑动插件","url":"/2023/03/15/Js%E6%A8%A1%E6%8B%9F%E6%83%AF%E6%80%A7%E6%BB%91%E5%8A%A8%E6%8F%92%E4%BB%B6/","content":"\n\n你小子，看到有标题就点啊，没了，晚点再更\n","categories":["Web的日常经验分享"],"tags":["javascript"]},{"title":"React学习笔记","url":"/2024/12/15/React%E7%AC%94%E8%AE%B0/","content":"Day01\njsx语法\n\n\n插值符号 ： {} ； 在标签中可以嵌套Jsx语法\n\n\n在插值符号里面可以写的内容如下：\n\n表达式\n数组\n字符串\n即时函数\n布尔值\n三目表达式\n\n\njsx语法多行注释：\n &#123;/*    这是多行注释*/&#125;\n\n！ 注意 ！在写React的时候要区分哪部分是写Js的区块，哪部分是写Jsx的区块！！\n\n\njsx渲染json数据\n let json = &#123;    &quot;name&quot;:&quot;张三&quot;,    &quot;age&quot;:&quot;18&quot;,    &quot;job&quot;:&quot;学生&quot;，    &quot;state&quot;:true,&#125;  let element = &lt;div&gt;    &lt;h4&gt;&#123;json.name&#125;&lt;/h4&gt;    &lt;h4&gt;&#123;json.age&#125;&lt;/h4&gt;    &lt;h4&gt;&#123;json.job&#125;&lt;/h4&gt;    &lt;h4&gt;&#123;json.state&#125;&lt;/h4&gt; /* 不会直接渲染出字符状态的布尔值 */ &lt;/div&gt; ReactDom.render(    elment,    document.getElementById(&quot;app&quot;) )\njsx数组遍历\n &#123;&lt;ul&gt;    &#123;        arr.map( (item, idx , self ) =&gt; &#123;            console.log(item)            return &lt;li key=&#123;idx&#125;&gt;  &#123;item&#125; &lt;/li&gt;        &#125;)    &#125;&lt;/ul&gt;&#125;\n\n！ 注意 ！在遍历的时候，需要加上key；这个key值在开发中最后不要用idx，因为后期会出现diff算法比较的问题！！\n\n\n\n\n样式处理\n\n\n行内样式处理 const Element = &lt;div&gt;    &#123;/* 使用单标签的时候也需要记得闭合标签，且在写样式的时候，键值对的键需要遵循驼峰命名 */&#125;    &lt;h3 style=&#123;&#123;&quot;backgroundColor&quot;:&quot;#f90&quot;&#125;&#125;&gt; Hello React &lt;/h3&gt;&lt;/div&gt;ReactDom.render(    Element,    document.getElementById(&#x27;app&#x27;))\n内链样式处理 let style = &#123;&quot;backgroundColor&quot;:&quot;#f90&quot;,width:&quot;50px&quot;,height:&quot;50px&quot;&#125;let style2 = &#123;    s1:&#123;        &quot;backgroundColor&quot;:&quot;#ffo&quot;,        width:&quot;50px&quot;,        height:&quot;50px&quot;,        color:&quot;pink&quot;        &#125;,    s2:&#123;&quot;backgroundColor&quot;:&quot;#0f0&quot;,        width:&quot;50px&quot;,        height:&quot;50px&quot;,        color:&quot;blue&quot;        &#125;&#125;const Element = &lt;div&gt;    &lt;h3 style=&#123;style&#125;&gt; Hello React1 &lt;/h3&gt;    &lt;h3 style=&#123;style2.s1&#125;&gt; Hello React2 &lt;/h3&gt;    &lt;h3 style=&#123;style2.s2&#125;&gt; Hello React3 &lt;/h3&gt;&lt;/div&gt;ReactDom.render(    Element,    document.getElementById(&#x27;app&#x27;))\n\n\n事件处理\n\n\n在jsx中引用js的 变量、函数、对象,以及组件的正常写法 &lt;button    onClick = &#123;function()&#123;alert(123)&#125;&#125;    &gt; 点击事件1&lt;/button&gt;\n\n\nDay02\n复习面向对象\n\n\n构造函数(es5)\n function Person( name, age, sex )&#123;    this.name = name;    this.age = age;    this.sex = sex; &#125;var per1 = Person( &quot;张三&quot; ， 18 ， &quot;男&quot;)    // 实例化对象var per2 = Person( &quot;李四&quot; ， 19  ， &quot;男&quot;)   // 实例化对象console.log( per1 )console.log( per2 )\n原型共享(es5)\n Person.prototype = fn.prototypePerson.prototype.sex = &quot;男&quot;function Person( name, age, sex )&#123;        this.name = name;        this.age = age;        this.sex = sex;     &#125;function fn()&#123;&#125;        var per1 = Person( &quot;张三&quot; ， 18 ， &quot;男&quot;)        var per2 = Person( &quot;李四&quot; ， 19  ， &quot;男&quot;)       var fn1 = new fn();     console.log( per1 )    console.log( per2 )\n构造函数(es6)\n class Person&#123;    constructor( name age , sex )&#123; // 构造器        this.name = name;*        this.age = age;        this.sex = sex;     &#125;&#125;var per1 = new Person( &quot;王五&quot; ， 20 ， &quot;男&quot; );console.log( per1 )\n\n组件基础\n\n\n组件的核心理论概念：\n\n以技能竞赛为例子，三个人合作写项目，每个人负责不同的模块，最好再把各自的模块拼在一起，形成最终的作品，但是考虑到兼容性，编码习惯，往往整合模块这里非常费时间，每个人写的js，css，DOM结构都大不相同\n要避免冲突，防止1+1 = -1的情况出现，每个人都有一个自己名字的文件夹，文件夹里面包括html、css、js、三个人合作，就有三个不同名字，模块不同的文件夹，而这三个文件夹，就可以理解为一个独立的组件，所以，可以简单的理解为，组件就是拥有自己独立的html、css、js的一个模块，通过React，让组件与组件之间可以相互兼容，封装好的组件可以反复多次调用，即插即用\nReact中，有函数组件渲染静态内容，由类组件渲染动态内容，以达到页面的最佳性能，是否使用类组件，取决于组件中是否要进行数据管理，组件负责统一渲染DOM，state负责统一控制数据。\n\n\nReact的核心就是组件，DOM结构交给组件渲染 \n //组件的常见写法：function Sec() &#123;    return (        &lt;section&gt;        &lt;div className=&quot;sidebar&quot;&gt; 我是侧边栏 &lt;/div&gt;        &lt;div className=&quot;banner&quot;&gt; 我是轮播图 &lt;/div&gt;    &lt;/section&gt;    )&#125;let Element = &lt;div&gt;    &lt;h1&gt;这里是组件的内容&lt;/h1&gt;    &lt;header&gt;我是头部组件&lt;/header&gt;    &lt;Sec&gt;&lt;/Sec&gt;    &lt;footer&gt; 我是底部组件 &lt;/footer&gt;&lt;/div&gt;ReactDom.render(    Element,    document.getElementById(&quot;app&quot;))\n\n有状态组件\n\n\n\n","categories":["React 笔记"],"tags":["React 笔记"]},{"title":"Hello World","url":"/2023/04/25/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"git笔记","url":"/2023/05/05/git%E7%AC%94%E8%AE%B0/","content":"配置Git配置git的个人信息，用于在团队项目中区分提交源码的人分别是谁git config –global user.name &quot;自定义的名字&quot;\ngit config –global user.email &quot;自定义的邮箱&quot;\n\n使用Git初始化和基本操作\n查看改目录是否有git,或者查看文件当前的状态git status\n对没有git的目录初始化git，使该目录归属到git的管辖范围内git init\n文件的状态分两种 :\n未跟踪 \n\n\n\n\n\n已跟踪\n\n未修改 暂存    已修改\n\n\n\n修改了的文件都是已修改状态，新建的文件是未跟踪状态，需要先把文件提交到暂存区再上交远程仓库，上交完远程之后的文件就会变成未修改状态\n\n\n\n将文件提交到暂存区，文件状态由 已修改 –&gt; 暂存 ;“git add .”是提交全部已修改文件git add &lt;文件名字&gt;或git add .\n将暂存区的文件上交到仓库中，”git commit -a -m ‘xxxxx’” 提交所有已修改的文件，但是新建的文件未跟踪的文件不会提交  上交之后，文件的状态由 暂存 –&gt; 未修改git commit -m &#x27;描述一下你这次提交了什么&#x27;或git commit -a -m &#x27;描述一下你这次提交了什么&#x27;\n重到上一次提交的状态,”.\\index.html”就是你要重置的文件路径，重置文件 ：git restore .\\index.html # 恢复文件到上一次提交的状态或git restore --staged &lt;文件名字&gt; # 取消暂存状态\n删除文件 :git rm &lt;文件名&gt; # 删除文件或git rm &lt;文件名&gt; # 强制删除\n\n\n分支\n","categories":["笔记"],"tags":["git"]},{"title":"真·轮播视频实现，附加缩略图功能","url":"/2023/04/25/%E7%9C%9F%C2%B7%E8%BD%AE%E6%92%AD%E8%A7%86%E9%A2%91%E5%AE%9E%E7%8E%B0%EF%BC%8C%E9%99%84%E5%8A%A0%E7%BC%A9%E7%95%A5%E5%9B%BE%E5%8A%9F%E8%83%BD/","content":"轮播视频的概念极其适用场景和实现方法你真的需要轮播视频吗 \n\n\n\n不懂了吧 网上的轮播视频粗略看一圈下来，基本都是把轮播图的img图片位置换成了video视频，这种时间一到就直接下一张的轮播并不符合我们的需求我们需要的是可以获取到视频播放长度，在视频彻底播放完之后才轮播到下一个视频的真轮播视频。这个时候就需要用到我们深厚且扎实的js功底，以我自己的轮播视频为例，先简单写一下基础的HTML和css布局  \n以下是HTML的部分&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot;          content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;    &lt;title&gt;轮播视频&lt;/title&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;banner.css&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- 2. banner start --&gt;&lt;section id=&quot;banner&quot;&gt;    &lt;div class=&quot;videos-loop&quot;&gt;        &lt;div class=&quot;vp-area&quot;&gt;            &lt;video muted autoplay&gt;                &lt;source src=&quot;supreme.mp4&quot; type=&quot;video/mp4&quot;&gt;            &lt;/video&gt;        &lt;/div&gt;        &lt;div class=&quot;thumbnails&quot;&gt;            &lt;div class=&quot;video-item playing&quot;&gt;                &lt;video muted&gt;                    &lt;source src=&quot;supreme.mp4&quot; type=&quot;video/mp4&quot;&gt;                &lt;/video&gt;                &lt;div class=&quot;video-item-content&quot;&gt;                    &lt;h3&gt;There are birds that only land once in a lifetime.&lt;/h3&gt;                    &lt;p&gt;Do you want to know why? The time it landed was when it died.&lt;/p&gt;                &lt;/div&gt;            &lt;/div&gt;            &lt;div class=&quot;video-item&quot;&gt;                &lt;video muted&gt;                    &lt;source src=&quot;nike.mp4&quot; type=&quot;video/mp4&quot;&gt;                &lt;/video&gt;                &lt;div class=&quot;video-item-content&quot;&gt;                    &lt;h3&gt;There are birds that only land once in a lifetime.&lt;/h3&gt;                    &lt;p&gt;Do you want to know why? The time it landed was when it died.Do you want to know why? The                        time it landed was when it died.Do you want to know why? The time it landed was when it                        died.Do you want to know why? The time it landed was when it died.Do you want to know why?                        The time it landed was when it died.&lt;/p&gt;                &lt;/div&gt;            &lt;/div&gt;            &lt;div class=&quot;video-item&quot;&gt;                &lt;video muted&gt;                    &lt;source src=&quot;adidas.mp4&quot; type=&quot;video/mp4&quot;&gt;                &lt;/video&gt;                &lt;div class=&quot;video-item-content&quot;&gt;                    &lt;h3&gt;There are birds that only land once in a lifetime.&lt;/h3&gt;                    &lt;p&gt;Do you want to know why? The time it landed was when it died.&lt;/p&gt;                &lt;/div&gt;            &lt;/div&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/section&gt;&lt;!-- 2. banner end --&gt;&lt;/body&gt;&lt;script src=&quot;banner.js&quot;&gt;&lt;/script&gt;&lt;/html&gt;\n\n以下是CSS的部分可以按需删减　，此处的css随便写了几坨\n/*banner start*/#banner &#123;    margin-top: 100px;    width: 100%;    background-color: #000;    box-sizing: border-box;&#125;#banner .videos-loop &#123;    width: 1460px;    display: flex;    justify-content: space-between;    margin: 0 auto;&#125;#banner .videos-loop .vp-area &#123;    width: 1100px;    height: calc(1100px * 9 / 16);    background-color: #161616;&#125;#banner .videos-loop .vp-area video &#123;    width: 1100px;    height: calc(1100px * 9 / 16);&#125;#banner .videos-loop .thumbnails &#123;    width: calc(100% - 1100px);    height: calc(1100px * 9 / 16);    overflow: hidden;    display: flex;    flex-direction: column;    align-items: center;    background-color: #1e1e1e;&#125;#banner .videos-loop .thumbnails .video-item &#123;    width: 320px;    height: calc(120px);    padding: 10px;    display: flex;    transition: 0.5s ease-in-out;    border-radius: 4px;    cursor: pointer;&#125;#banner .videos-loop .thumbnails .video-item video &#123;    width: calc(320px * 0.4);    height: calc(calc(320px * 0.4) * 9 / 16);    object-fit: cover;    margin-right: 15px;    margin-top: 20px;&#125;#banner .videos-loop .thumbnails .video-item .video-item-content &#123;    flex: 1;    width: calc(calc(320px - calc(320px * 0.4)) - 15px);&#125;#banner .videos-loop .thumbnails .video-item .video-item-content h3 &#123;    width: inherit;    white-space: nowrap;    overflow: hidden;    text-overflow: ellipsis;    font-size: 16px;    color: rgba(255, 255, 255, 0.6);    margin-bottom: 12px;    transition: 0.2s ease-in-out;&#125;#banner .videos-loop .thumbnails .video-item .video-item-content p &#123;    width: inherit;    overflow: hidden;    text-overflow: ellipsis;    display: -webkit-box;    -webkit-box-orient: vertical;    -webkit-line-clamp: 2;    font-size: 16px;    color: #ccc;    transition: 0.2s ease-in-out;&#125;#banner .videos-loop .thumbnails .video-item:hover &#123;    background-color: #363636;&#125;#banner .videos-loop .thumbnails .video-item:hover .video-item-content h3 &#123;    color: #ffffff;&#125;#banner .videos-loop .thumbnails .video-item:hover .video-item-content p &#123;    color: #ccc;&#125;#banner .videos-loop .thumbnails .video-item.playing &#123;    background-color: #363636;&#125;#banner .videos-loop .thumbnails .video-item.playing .video-item-content h3 &#123;    color: #ffffff;&#125;#banner .videos-loop .thumbnails .video-item.playing .video-item-content p &#123;    color: #ccc;&#125;@media (min-width: 992px) and (max-width: 1200px) &#123;    #banner .videos-loop &#123;        width: 1160px;        display: flex;        justify-content: space-between;        margin: 0 auto;    &#125;    #banner .videos-loop .vp-area &#123;        width: 800px;        height: calc(800px * 9 / 16);        background-color: #161616;    &#125;    #banner .videos-loop .vp-area video &#123;        width: 800px;        height: calc(800px * 9 / 16);    &#125;    #banner .videos-loop .thumbnails &#123;        width: calc(100% - 800px);        height: calc(800px * 9 / 16);        overflow: hidden;        display: flex;        flex-direction: column;        align-items: center;        background-color: #1e1e1e;    &#125;&#125;@media (min-width: 700px) and (max-width: 992px) &#123;    #banner .videos-loop &#123;        width: 860px;        display: flex;        justify-content: space-between;        margin: 0 auto;    &#125;    #banner .videos-loop .thumbnails &#123;        width: calc(100% - 500px);        height: calc(650px * 9 / 16);        overflow: hidden;        display: flex;        flex-direction: column;        align-items: center;        background-color: #1e1e1e;    &#125;    #banner .videos-loop .vp-area &#123;        width: 500px;        height: calc(500px * 9 / 16);        background-color: #161616;    &#125;    #banner .videos-loop .vp-area video &#123;        width: 500px;        height: calc(500px * 9 / 16);        margin-top: 50px;    &#125;&#125;@media (max-width: 700px) &#123;    #banner .videos-loop &#123;        width: 480px;        display: flex;        flex-direction: column;        justify-content: space-between;        margin: 0 auto;    &#125;    #banner .videos-loop .vp-area &#123;        width: 480px;        height: calc(500px * 9 / 16);        background-color: #161616;    &#125;    #banner .videos-loop .vp-area video &#123;        width: 480px;        height: calc(600px * 9 / 16);    &#125;    #banner .videos-loop .thumbnails &#123;        width: calc(100% - 500px);        height: calc(500px * 9 / 16);        overflow: hidden;        display: flex;        flex-direction: column;        align-items: center;        background-color: #1e1e1e;    &#125;    #banner .videos-loop .thumbnails .video-item &#123;        width: 500px;        height: calc(120px);        padding: 10px;        display: flex;        transition: 0.5s ease-in-out;        border-radius: 4px;        cursor: pointer;        margin-bottom: 0;    &#125;    #banner .videos-loop .thumbnails &#123;        width: 480px;        height: calc(670px * 9 / 16);        overflow: hidden;        display: flex;        flex-direction: column;        align-items: center;        background-color: #1e1e1e;    &#125;&#125;/*banner end*/\n\n然后，把功能拆分，先实现轮播功能，这里就不细说了，直接上内容\nlet currIndex = 0;   let playA = document.querySelector(&quot;.vp-area&quot;);   let thumb = [...document.querySelectorAll(&quot;.thumbnails &gt; .video-item &gt; video&quot;)];   let playTime = null;   let smWindow = undefined;   // 轮播视频的主视频播放区域   const bannerVideo = function (event) &#123;       playA.children[0].removeEventListener(&quot;ended&quot;,bannerVideo);       document.querySelector(&quot;.playing&quot;).classList.remove(&quot;playing&quot;);       if (event.type != &quot;click&quot;) currIndex = ++currIndex % thumb.length;       let videoDom =                `&lt;video muted autoplay&gt;                    &lt;source src=&quot;$&#123;thumb[currIndex].children[0].getAttribute(&quot;src&quot;)&#125;&quot; type=&quot;video/mp4&quot;&gt;                &lt;/video&gt;`;       playA.innerHTML=videoDom;       thumb[currIndex].parentElement.classList.add(&quot;playing&quot;);       playA.children[0].addEventListener(&quot;ended&quot;,bannerVideo);   &#125;\n\n然后就是缩略图功能，当鼠标移到缩略图范围内时，主视频区的视频暂停，开始播放缩略图视频，鼠标移开缩略图时，主视频继续播放，如果点击了指定的视频，则播放指定的视频\n// 缩略图   const smallVideo = function () &#123;        let videos = document.querySelectorAll(&quot;.video-item&quot;);        videos.forEach((el,index) =&gt; &#123;            el.addEventListener(&quot;click&quot;, (event) =&gt; &#123;                if (smWindow != undefined) &#123;                    thumb[smWindow].pause();                    thumb[smWindow].currentTime = 0;                    playA.children[0].play();                &#125;                if (currIndex == index) return;                currIndex = index;                bannerVideo(event);            &#125;);            el.addEventListener(&quot;mouseover&quot;,() =&gt; &#123;                playTime = setTimeout(() =&gt;&#123;                    smWindow = index;                    playA.children[0].pause();                    thumb[index].play();                &#125;,100);            &#125;);            el.addEventListener(&quot;mouseleave&quot;, () =&gt; &#123;               clearTimeout(playTime);               setTimeout(()=&gt;&#123;                  smWindow = undefined;                  thumb[index].pause();                  thumb[index].currentTime = 0;                  playA.children[0].play();               &#125;,100);            &#125;);        &#125;);   &#125;\n\n\n完整的js内容如下(function () &#123;    let currIndex = 0;//当前播放着的视频索引，默认为视频列表第一个    let smWindow = undefined;//视频列表中当前在后台播放的视频的索引    let playtime = null;//获取setTimeout返回的句柄,方便取消setTimeout    // 扩展运算符... 可以获取剩下的所有数组参数，这里的thumb相当于绑定了缩略图的三个视频，以数组的形式储存    let thumb = [...document.querySelectorAll(&quot;.thumbnails &gt; .video-item &gt; video&quot;)];    let playbanner = document.querySelector(&quot;.vp-area&quot;)// 轮播视频正在播放的播放区域    // 轮播视频的播放函数    const bannerVideo = function (event) &#123;        // 触发了轮播视频的函数，就先判断视频是怎么被触发的，是视频放完了播下一个视频，还是因为缩略图被点击之后放的下一个        // 如果触发轮播函数的方式不是点击的，那就是视频放完了到下一个了，给索引先自增之后，在对视频列表的长度取余        //假设这里的索引是2，播放的是第三个视频，先自增之后就是3，3除以视频列表的长度3，3除3等于1，余数是0，        // 取余之后赋值给索引，所以索引就是0，这样播放完最后一个视频，就会重置索引到0，重新播放第一个视频        if (event.type != &quot;click&quot;) currIndex = ++currIndex % thumb.length;        // 定义一下需要动态渲染的播放区域        let videoDom = `&lt;video muted autoplay&gt;&lt;!--   用插值表达式动态渲染src路径  thumb这个数组里面第currIndex个参数的第一个子元素source的视频路径--&gt;&lt;!--   getAttribute方法返回一个元素属性的值，这里返回的src相当于获取缩略图的的视频路径，根据缩略图的排序来划分视频播放列表--&gt;                &lt;source src=&quot;$&#123;thumb[currIndex].children[0].getAttribute(&quot;src&quot;)&#125;&quot; type=&quot;video/mp4&quot;&gt;            &lt;/video&gt;`        // 把这个动态渲染的html替换掉原本html里的静态内容        playbanner.innerHTML = videoDom;        // 给播放视频区域的第一个子元素，也就是主视频添加一个ended事件，当视频播放完之后，再次调用该函数        playbanner.children[0].addEventListener(&quot;ended&quot;,bannerVideo);    &#125;    // 缩略图    const smBannerVideo = function () &#123;        // 获取缩略图的类名        let videos = document.querySelectorAll(&quot;.video-item&quot;);        // 给缩略图循环添加三个事件        // callbackfn为数组中每个元素执行的函数,并携带两个参数        // element是数组中正在处理的当前元素   index是数组中正在处理的当前元素的索引        videos.forEach((el,index)  =&gt;&#123;            el.addEventListener(&quot;click&quot;,(event)=&gt;&#123;                //如果有视频列表中有视频在后台播放，则暂停并重置它，然后恢复主视频的播放                if (smWindow != undefined) &#123;                    // pause方法暂停缩略图正在放的视频                    thumb[smWindow].pause();                    // currentTime使视频的播放进度归零                    thumb[smWindow].currentTime = 0;                    // play方法，让主视频区域的视频继续播放                    playbanner.children[0].play();                &#125;                if (currIndex == index) return;// 如果点击的是当前视频就退出                currIndex = index;//解决了pc端，鼠标移入视频列表区域中的视频时，点击该视频，播放区域主视频和视频列表中该视频同时播放的问题                bannerVideo(event);            &#125;)            el.addEventListener(&quot;mouseover&quot;,()=&gt;&#123;                 setTimeout(() =&gt;&#123;                    smWindow = index;                    playbanner.children[0].pause();                    thumb[index].play();                &#125;,100);            &#125;)            el.addEventListener(&quot;mouseleave&quot;,()=&gt;&#123;                setTimeout(()=&gt;&#123;                    thumb[index].pause();                    thumb[index].currentTime = 0;// 视频播放进度归0                    playbanner.children[0].play();                &#125;,100);            &#125;)        &#125;);    &#125;    const run = function () &#123;        // 绑定第一个视频        let videoElem = playbanner.children[0];        // 给第一个视频添加事件，用ended事件，在视频播放完之后，触发轮播视频的函数        videoElem.addEventListener(&quot;ended&quot;, bannerVideo);        // 执行缩略图        smBannerVideo();    &#125;    run();&#125;)()\n\n小结那么到此为止，一套完整的轮播视频＋缩略图就这么点了　　虽然细节没有说到位，但是反复看两遍源码，逻辑还是很简单的，点到为止，下播\n","categories":["Web的日常经验分享"],"tags":["javascript"]}]